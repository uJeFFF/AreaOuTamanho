<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Área ou Tamanho? Verificador de proporções em visualizações de dados</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; display: flex; flex-direction: column; align-items: center; }
        #canvas-container { position: relative; width: 800px; height: 600px; border: 2px solid #ccc; background-color: #f0f0f0; overflow: hidden; }
        .canvas-wrapper { border-radius: 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .controls, .analysis { margin-top: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; width: 800px; box-sizing: border-box; background-color: #fafafa; }
        .controls button { padding: 8px 12px; margin: 5px; cursor: pointer; border: 1px solid #aaa; border-radius: 4px; background-color: #fff; }
        .controls button.active { background-color: #007bff; color: white; border-color: #007bff; }
        .controls .color-picker { display: inline-flex; align-items: center; gap: 10px; margin-top: 10px; }
        .analysis .input-group { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .analysis .input-group label { flex-shrink: 0; }
        .analysis .input-group input[type="number"] { width: 100px; }
        .analysis .input-group .ref-label { cursor: pointer; font-size: 0.9em; user-select: none;}
        .analysis .checkbox-group { margin: 10px 0; }
        #result { font-weight: bold; line-height: 1.6; }
        #result small { font-weight: normal; color: #333; }
        #pen-instructions { margin-top: 10px; color: #555; font-style: italic; display: none; }
        #tooltip { position: absolute; display: none; background-color: #333; color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 100; }
    </style>
</head>
<body>
    <h3>Área ou Tamanho? Verificador de proporções em visualizações de dados</h3>

    <div class="controls">
        <label for="uploader">1. Carregar imagem de fundo:</label>
        <input type="file" id="uploader">
        <hr>
        <p style="font-size: 0.9em; color: #333;"><b>Dica:</b> Use o scroll do mouse para dar <b>ZOOM</b>. Segure <b>[ALT]</b> e arraste com o mouse para navegar (<b>PAN</b>).</p>
        <label>2. Escolha a ferramenta:</label><br>
        <button id="tool-select" class="active">Selecionar / Mover / Editar</button>
        <button id="tool-rect">Adicionar Retângulo</button>
        <button id="tool-circle">Adicionar Círculo</button>
        <button id="tool-pen">Caneta (Estilo Illustrator)</button>
        <button id="tool-clear" style="float: right; background-color: #fce8e6; border-color: #e57373;">Limpar Formas</button>
        <p id="pen-instructions">Modo Caneta: Clique para pontos retos. Clique e ARRASTE para curvas. Pressione [Ctrl+Z] para desfazer o último ponto. Clique no ponto inicial para fechar a forma. Pressione [Enter] para finalizar.</p>
        <div class="color-picker">
            <label for="shapeColor">Cor da Forma:</label>
            <input type="color" id="shapeColor" value="#FFA500">
            <label for="shapeOpacity">Transparência:</label>
            <input type="range" id="shapeOpacity" min="0" max="1" value="0.3" step="0.1">
        </div>
    </div>

    <div id="canvas-container">
        <div id="tooltip"></div>
        <canvas id="drawing-canvas" width="800" height="600"></canvas>
    </div>

    <div class="analysis">
        <h3>3. Análise dos Valores</h3>
        <div id="value-inputs-container"></div>
        <div class="checkbox-group">
            <strong>Verificar proporção de:</strong><br>
            <input type="checkbox" id="check-area" name="check-area" checked> <label for="check-area">Área</label>
            <input type="checkbox" id="check-height" name="check-height"> <label for="check-height">Altura</label>
            <input type="checkbox" id="check-width" name="check-width"> <label for="check-width">Largura</label>
        </div>
        <button id="verify-btn">Verificar Proporções</button>
        <div id="result"><h3>Resultado:</h3></div>
    </div>

    <script>
        const canvas = new fabric.Canvas('drawing-canvas', { selection: true });

        // --- Variáveis de Estado ---
        let shapeCounter = 0;
        let isDrawingPath = false, currentPath, pathSegments = [], lastPoint = null, firstPoint = null, isDraggingHandle = false, downPoint = null;

        // --- Referências ao DOM ---
        const uploader = document.getElementById('uploader'), toolButtons = document.querySelectorAll('.controls button'), penInstructions = document.getElementById('pen-instructions'), resultDisplay = document.getElementById('result'), shapeColorInput = document.getElementById('shapeColor'), shapeOpacityInput = document.getElementById('shapeOpacity'), valueInputsContainer = document.getElementById('value-inputs-container'), tooltip = document.getElementById('tooltip');

        // =======================================================
        //  LÓGICA DE ZOOM E PAN
        // =======================================================
        canvas.on('mouse:wheel', function(opt) {
            opt.e.preventDefault();
            opt.e.stopPropagation();

            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 20) zoom = 20; // Limite máximo de zoom
            // >>> ALTERAÇÃO 1: Limite mínimo de zoom agora é 1 (tamanho original) <<<
            if (zoom < 1) zoom = 1;

            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
        });

        canvas.on('mouse:down', function(opt) {
            const evt = opt.e;
            // O pan só é ativado se a tecla ALT estiver pressionada E não estivermos no modo caneta
            if (evt.altKey === true && !document.getElementById('tool-pen').classList.contains('active')) {
                this.isDragging = true;
                this.selection = false;
                this.lastPosX = evt.clientX;
                this.lastPosY = evt.clientY;
            }
        });

        canvas.on('mouse:move', function(opt) {
            if (this.isDragging) {
                const e = opt.e;
                const vpt = this.viewportTransform;
                vpt[4] += e.clientX - this.lastPosX;
                vpt[5] += e.clientY - this.lastPosY;
                this.requestRenderAll();
                this.lastPosX = e.clientX;
                this.lastPosY = e.clientY;
            }
        });

        canvas.on('mouse:up', function(opt) {
            this.setViewportTransform(this.viewportTransform);
            this.isDragging = false;
            this.selection = true;
        });


        // =======================================================
        //  FUNÇÕES DE COR E ATUALIZAÇÃO
        // =======================================================
        function getRgbaColor() {
            const hex = shapeColorInput.value; const opacity = shapeOpacityInput.value;
            const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
        function updateSelectedObjectColor() {
            const newColor = getRgbaColor();
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length > 0) {
                activeObjects.forEach(obj => obj.set('fill', newColor));
                canvas.renderAll();
            }
        }
        shapeColorInput.addEventListener('input', updateSelectedObjectColor);
        shapeOpacityInput.addEventListener('input', updateSelectedObjectColor);

        // =======================================================
        //  LÓGICA DA FERRAMENTA CANETA (Resumido para simplicidade)
        // =======================================================
        canvas.on('mouse:down', (o) => { if (!document.getElementById('tool-pen').classList.contains('active')) return; if(this.isDragging) return; isDrawingPath = true; /* ... */ });
        canvas.on('mouse:move', (o) => { if (!isDrawingPath) return; /* ... */ });
        canvas.on('mouse:up', (o) => { if (!isDrawingPath) return; /* ... */ });

        // =======================================================
        //  TOOLTIP DE IDENTIFICAÇÃO DE FORMAS
        // =======================================================
        canvas.on('mouse:over', (e) => { if (e.target && e.target.shapeId) { tooltip.innerHTML = `Forma ${e.target.shapeId}`; tooltip.style.display = 'block'; } });
        canvas.on('mouse:out', () => { tooltip.style.display = 'none'; });
        canvas.on('mouse:move', (e) => { const pointer = canvas.getPointer(e.e); tooltip.style.left = `${pointer.x + 15}px`; tooltip.style.top = `${pointer.y + 10}px`; });

        // =======================================================
        //  EVENTOS DE TECLADO (UNDO, FINALIZAR, DELETAR)
        // =======================================================
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') finalizePath();
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { /* ... lógica de undo ... */ }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement.tagName === 'INPUT') return;
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.length > 0) {
                    activeObjects.forEach(obj => canvas.remove(obj));
                    canvas.discardActiveObject();
                    reindexAndPreserveUI();
                    canvas.renderAll();
                }
            }
        });

        function finalizePath(isClosed = false) {
            if (isDrawingPath) {
                isDrawingPath = false;
                if (pathSegments.length < 2 && !isClosed) { canvas.remove(currentPath); }
                else {
                    shapeCounter++;
                    const finalPath = new fabric.Path(pathSegments.join(' '), { strokeWidth: 0, fill: isClosed ? getRgbaColor() : 'transparent', selectable: true, objectCaching: false, perPixelTargetFind: isClosed, shapeId: shapeCounter });
                    canvas.remove(currentPath); canvas.add(finalPath); addValueInput(shapeCounter);
                }
                canvas.renderAll(); currentPath = null; pathSegments = []; lastPoint = null; firstPoint = null; isDraggingHandle = false; downPoint = null;
            }
        }

        // =======================================================
        //  FERRAMENTAS E FUNÇÕES AUXILIARES
        // =======================================================
        function addValueInput(id) {
            const isFirstInput = valueInputsContainer.children.length === 0;
            const inputDiv = document.createElement('div');
            inputDiv.className = 'input-group';
            inputDiv.id = `value-input-div-${id}`;
            inputDiv.innerHTML = `
                <label for="value-input-${id}">Valor da Forma ${id}:</label>
                <input type="number" id="value-input-${id}" placeholder="Ex: 100">
                <input type="radio" name="reference-shape" value="${id}" id="ref-radio-${id}" ${isFirstInput ? 'checked' : ''}>
                <label for="ref-radio-${id}" class="ref-label">Usar como referência</label>
            `;
            valueInputsContainer.appendChild(inputDiv);
        }

        function removeValueInput(id) {
            const inputDiv = document.getElementById(`value-input-div-${id}`);
            if (inputDiv) inputDiv.remove();
        }

        function reindexAndPreserveUI() {
            const objects = canvas.getObjects();
            const state = [];
            objects.forEach(obj => {
                const valueInput = document.getElementById(`value-input-${obj.shapeId}`);
                const radioInput = document.getElementById(`ref-radio-${obj.shapeId}`);
                state.push({
                    objRef: obj, value: valueInput ? valueInput.value : '',
                    isRef: radioInput ? radioInput.checked : false, oldId: obj.shapeId
                });
            });
            state.sort((a, b) => a.oldId - b.oldId);
            valueInputsContainer.innerHTML = '';
            let hasRefBeenSet = false;
            state.forEach((item, index) => {
                const newId = index + 1;
                item.objRef.shapeId = newId;
                const inputDiv = document.createElement('div');
                inputDiv.className = 'input-group';
                inputDiv.id = `value-input-div-${newId}`;
                let isCheckedAttr = '';
                if (item.isRef) { isCheckedAttr = 'checked'; hasRefBeenSet = true; }
                inputDiv.innerHTML = `
                    <label for="value-input-${newId}">Valor da Forma ${newId}:</label>
                    <input type="number" id="value-input-${newId}" placeholder="Ex: 100" value="${item.value}">
                    <input type="radio" name="reference-shape" value="${newId}" id="ref-radio-${newId}" ${isCheckedAttr}>
                    <label for="ref-radio-${newId}" class="ref-label">Usar como referência</label>
                `;
                valueInputsContainer.appendChild(inputDiv);
            });
            if (!hasRefBeenSet && state.length > 0) {
                const firstRadio = valueInputsContainer.querySelector('input[type="radio"]');
                if (firstRadio) { firstRadio.checked = true; }
            }
            shapeCounter = state.length;
        }

        function setTool(tool) {
            toolButtons.forEach(button => button.classList.remove('active'));
            document.getElementById(`tool-${tool}`).classList.add('active');
            canvas.isDrawingMode = false;
            canvas.selection = tool === 'select';
            canvas.forEachObject(o => o.selectable = tool === 'select');
            penInstructions.style.display = tool === 'pen' ? 'block' : 'none';
            finalizePath();
        }

        function addShape(shapeType) {
            finalizePath();
            shapeCounter++;
            let shape;
            const options = { left: 150, top: 150, strokeWidth: 0, fill: getRgbaColor(), perPixelTargetFind: true, shapeId: shapeCounter };
            if (shapeType === 'rect') shape = new fabric.Rect({ ...options, width: 150, height: 100 });
            if (shapeType === 'circle') shape = new fabric.Circle({ ...options, radius: 50 });
            if (shape) {
                canvas.add(shape);
                addValueInput(shapeCounter);
            }
            setTool('select');
        }

        document.getElementById('tool-select').addEventListener('click', () => setTool('select')); document.getElementById('tool-pen').addEventListener('click', () => setTool('pen')); document.getElementById('tool-rect').addEventListener('click', () => addShape('rect')); document.getElementById('tool-circle').addEventListener('click', () => addShape('circle'));

        // >>> ALTERAÇÃO 2: Botão "Limpar Formas" agora preserva o fundo <<<
        document.getElementById('tool-clear').addEventListener('click', () => {
             finalizePath();

             // Remove todos os objetos um por um, para não apagar a imagem de fundo.
             const objects = canvas.getObjects();
             objects.forEach(obj => canvas.remove(obj));

             valueInputsContainer.innerHTML = '';
             shapeCounter = 0;
             resultDisplay.innerHTML = '<h3>Resultado:</h3>';

             canvas.discardActiveObject(); // Limpa a seleção
             canvas.renderAll(); // Renderiza o canvas limpo
        });

        uploader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    // Reseta o zoom e o pan ao carregar uma nova imagem
                    canvas.setZoom(1);
                    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);

                    const imageUrl = event.target.result;
                    fabric.Image.fromURL(imageUrl, function(img) {
                        const canvasWidth = 800;
                        const canvasHeight = 600;
                        const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height);

                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            scaleX: scale,
                            scaleY: scale,
                            top: canvasHeight / 2,
                            left: canvasWidth / 2,
                            originX: 'center',
                            originY: 'center'
                        });
                    });
                };
                reader.readAsDataURL(file);
            }
        });

        // =======================================================
        //  FUNÇÃO PARA CÁLCULO DE ÁREA REAL
        // =======================================================
        function getRealArea(obj) {
            const scaleX = obj.scaleX || 1;
            const scaleY = obj.scaleY || 1;
            switch (obj.type) {
                case 'rect': return obj.width * obj.height * scaleX * scaleY;
                case 'circle': return Math.PI * Math.pow(obj.radius, 2) * scaleX * scaleY;
                case 'path':
                    console.warn(`Cálculo de área para 'path' (Forma ${obj.shapeId}) é impreciso e usa a bounding box.`);
                    const pathBox = obj.getBoundingRect(); return pathBox.width * pathBox.height;
                default:
                    const defaultBox = obj.getBoundingRect(); return defaultBox.width * defaultBox.height;
            }
        }

        // =======================================================
        //  LÓGICA DE CÁLCULO (Sem alterações)
        // =======================================================
        document.getElementById('verify-btn').addEventListener('click', () => {
            const objects = canvas.getObjects();
            if (objects.length < 2) { resultDisplay.innerHTML = "<h3>Resultado:</h3>É preciso ter ao menos duas formas para comparar."; return; }

            const checkedRadio = document.querySelector('input[name="reference-shape"]:checked');
            if (!checkedRadio) { resultDisplay.innerHTML = "<h3>Resultado:</h3><span style='color:red;'>Selecione uma forma como referência.</span>"; return; }

            const referenceShapeId = parseInt(checkedRadio.value, 10);

            const values = {};
            let allValuesValid = true;
            for (const obj of objects) {
                const input = document.getElementById(`value-input-${obj.shapeId}`);
                const value = parseFloat(input.value);
                if (isNaN(value) || value <= 0) { input.style.borderColor = 'red'; allValuesValid = false; }
                else { input.style.borderColor = ''; values[obj.shapeId] = value; }
            }
            if (!allValuesValid) { resultDisplay.innerHTML = "<h3>Resultado:</h3><span style='color:red;'>Preencha todos os valores com números positivos.</span>"; return; }

            const checkArea = document.getElementById('check-area').checked;
            const checkHeight = document.getElementById('check-height').checked;
            const checkWidth = document.getElementById('check-width').checked;

            const baseObject = objects.find(obj => obj.shapeId === referenceShapeId);
            const baseValue = values[baseObject.shapeId];
            const TOLERANCIA = 0.05;
            let resultsHtml = [];

            for (const currentObject of objects) {
                if (currentObject.shapeId === referenceShapeId) continue;

                const currentValue = values[currentObject.shapeId];
                const currentRect = currentObject.getBoundingRect();
                const baseRect = baseObject.getBoundingRect();

                resultsHtml.push(`<hr><h4>Análise da Forma ${currentObject.shapeId} (em relação à Forma ${referenceShapeId})</h4>`);
                const ratioNumerico = currentValue / baseValue;

                if (checkArea) {
                    const realAreaBase = getRealArea(baseObject);
                    const realAreaCurrent = getRealArea(currentObject);
                    const ratioArea = (realAreaBase !== 0) ? (realAreaCurrent / realAreaBase) : 0;
                    const erroArea = Math.abs(ratioArea / ratioNumerico - 1) * 100; const cor = erroArea <= (TOLERANCIA * 100) ? 'green' : 'red';
                    resultsHtml.push(`<div style="margin-bottom: 12px;"><strong style="color:${cor};">Área:</strong><br><small>Proporção numérica: ${ratioNumerico.toFixed(2)}</small><br><small>Proporção das formas: ${ratioArea.toFixed(2)}</small><br><span style="color:${cor};">Discrepância de ${erroArea.toFixed(1)}%.</span></div>`);
                }
                if (checkHeight) {
                    const ratioAltura = currentRect.height / baseRect.height;
                    const erroAltura = Math.abs(ratioAltura / ratioNumerico - 1) * 100; const cor = erroAltura <= (TOLERANCIA * 100) ? 'green' : 'red';
                    resultsHtml.push(`<div style="margin-bottom: 12px;"><strong style="color:${cor};">Altura:</strong><br><small>Proporção numérica: ${ratioNumerico.toFixed(2)}</small><br><small>Proporção das formas: ${ratioAltura.toFixed(2)}</small><br><span style="color:${cor};">Discrepância de ${erroAltura.toFixed(1)}%.</span></div>`);
                }
                if (checkWidth) {
                    const ratioLargura = currentRect.width / baseRect.width;
                    const erroLargura = Math.abs(ratioLargura / ratioNumerico - 1) * 100; const cor = erroLargura <= (TOLERANCIA * 100) ? 'green' : 'red';
                    resultsHtml.push(`<div style="margin-bottom: 12px;"><strong style="color:${cor};">Largura:</strong><br><small>Proporção numérica: ${ratioNumerico.toFixed(2)}</small><br><small>Proporção das formas: ${ratioLargura.toFixed(2)}</small><br><span style="color:${cor};">Discrepância de ${erroLargura.toFixed(1)}%.</span></div>`);
                }
            }
            resultDisplay.innerHTML = "<h3>Resultado:</h3>" + resultsHtml.join('');
        });

        setTool('select');
    </script>
</body>
</html>